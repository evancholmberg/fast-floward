{"ast":null,"code":"var _jsxFileName = \"/home/evan/Documents/flow/fast-floward/quests/week1/day5/Artist/src/context/Flow.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useReducer, useEffect, useCallback } from 'react';\nimport * as fcl from '@onflow/fcl';\nimport * as FlowTypes from '@onflow/types';\nimport Picture from '../model/Picture.js';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Context = /*#__PURE__*/React.createContext({});\nconst constants = {\n  flowFormat: new Intl.NumberFormat('en-US', {\n    minimumFractionDigits: 4\n  })\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'setUser':\n      {\n        return { ...state,\n          user: action.payload\n        };\n      }\n\n    case 'setBalance':\n      {\n        return { ...state,\n          balance: action.payload\n        };\n      }\n\n    case 'setCollection':\n      {\n        if (action.payload) {\n          return { ...state,\n            collection: action.payload\n          };\n        } else {\n          return { ...state,\n            collection: action.payload\n          };\n        }\n      }\n\n    default:\n      return state;\n  }\n}\n\nfunction Provider(props) {\n  _s();\n\n  const [state, dispatch] = useReducer(reducer, {\n    user: null,\n    balance: null,\n    collection: undefined\n  });\n  const isReady = state.balance !== null && state.collection !== undefined;\n  const fetchBalance = useCallback(async () => {\n    if (state.user.addr && state.user.addr !== '0xLocalArtist') {\n      // A sample script execution.\n      // Query for the account's FLOW token balance.\n      const balance = await fcl.send([fcl.script`\n            import FungibleToken from 0x9a0766d93b6608b7\n            import FlowToken from 0x7e60df042a9c0868\n  \n            pub fun main(address: Address): UFix64 {\n              let vaultRef = getAccount(address)\n                .getCapability(/public/flowTokenBalance)\n                .borrow<&FlowToken.Vault{FungibleToken.Balance}>()\n                ?? panic(\"Could not borrow Balance reference to the Vault\");\n  \n              return vaultRef.balance;\n            }\n          `, fcl.args([fcl.arg(state.user.addr, FlowTypes.Address)])]).then(fcl.decode);\n      dispatch({\n        type: 'setBalance',\n        payload: balance\n      });\n    } else {\n      return dispatch({\n        type: 'setBalance',\n        payload: -42\n      });\n    }\n  }, [state.user]);\n  const createCollection = useCallback(async () => {\n    const transactionId = await fcl.send([fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n          \n          transaction() {\n            prepare(account: AuthAccount) {\n              account.save<@LocalArtist.Collection>(\n                <- LocalArtist.createCollection(),\n                to: /storage/LocalArtistPictureCollection\n              )\n              account.link<&{LocalArtist.PictureReceiver}>(\n                /public/LocalArtistPictureReceiver,\n                target: /storage/LocalArtistPictureCollection\n              )\n            }\n          }\n        `, fcl.payer(fcl.authz), fcl.proposer(fcl.authz), fcl.authorizations([fcl.authz]), fcl.limit(9999)]).then(fcl.decode);\n    return fcl.tx(transactionId).onceSealed();\n  }, []);\n  const destroyCollection = useCallback(async () => {\n    const transactionId = await fcl.send([fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n\n          transaction() {\n            prepare(account: AuthAccount) {\n              account.unlink(/public/LocalArtistPictureReceiver)\n              let collection <- account.load<@LocalArtist.Collection>(from: /storage/LocalArtistPictureCollection)\n              destroy collection\n            }\n          }\n        `, fcl.payer(fcl.authz), fcl.proposer(fcl.authz), fcl.authorizations([fcl.authz]), fcl.limit(9999)]).then(fcl.decode);\n    return fcl.tx(transactionId).onceSealed();\n  }, []);\n  const fetchCollection = useCallback(async address => {\n    if (address || state.user.addr) {\n      try {\n        let args = null;\n\n        if (address) {\n          // eslint-disable-next-line\n          args = fcl.args([fcl.arg(address, FlowTypes.Address)]);\n        } else {\n          // eslint-disable-next-line\n          args = fcl.args([fcl.arg(state.user.addr, FlowTypes.Address)]);\n        }\n\n        const collection = await fcl.send([fcl.script`\n              import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n      \n              pub fun main(address: Address): [LocalArtist.Canvas] {\n                let account = getAccount(address)\n                let pictureReceiverRef = account\n                  .getCapability<&{LocalArtist.PictureReceiver}>(/public/LocalArtistPictureReceiver)\n                  .borrow()\n                  ?? panic(\"Couldn't borrow picture receiver reference.\")\n              \n                return pictureReceiverRef.getCanvases()\n              }\n            `, args]).then(fcl.decode);\n        const mappedCollection = collection.map(serialized => new Picture(serialized.pixels, serialized.width, serialized.height));\n\n        if (address) {\n          return mappedCollection;\n        } else {\n          dispatch({\n            type: 'setCollection',\n            payload: mappedCollection\n          });\n        }\n      } catch (error) {\n        if (address) {\n          return null;\n        } else {\n          dispatch({\n            type: 'setCollection',\n            payload: null\n          });\n        }\n      }\n    }\n  }, [state.user]);\n  const printPicture = useCallback(async picture => {\n    const transactionId = await fcl.send([fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n\n          transaction(width: Int, height: Int, pixels: String) {\n            \n            let picture: @LocalArtist.Picture?\n            let collectionRef: &{LocalArtist.PictureReceiver}\n\n            prepare(account: AuthAccount) {\n              // Change to your contract account address.\n              let printerRef = getAccount(${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT})\n                .getCapability<&LocalArtist.Printer>(/public/LocalArtistPicturePrinter)\n                .borrow()\n                ?? panic(\"Couldn't borrow printer reference.\")\n                \n              self.picture <- printerRef.print(\n                width: width,\n                height: height,\n                pixels: pixels\n              )\n              self.collectionRef = account\n                .getCapability<&{LocalArtist.PictureReceiver}>(/public/LocalArtistPictureReceiver)\n                .borrow()\n                ?? panic(\"Couldn't borrow picture receiver reference.\")\n            }\n            execute {\n              if self.picture == nil {\n                destroy self.picture\n              } else {\n                self.collectionRef.deposit(picture: <- self.picture!)\n              }\n            }\n          }\n        `, fcl.args([fcl.arg(picture.width, FlowTypes.Int), fcl.arg(picture.height, FlowTypes.Int), fcl.arg(picture.pixels, FlowTypes.String)]), fcl.payer(fcl.authz), fcl.proposer(fcl.authz), fcl.authorizations([fcl.authz]), fcl.limit(9999)]).then(fcl.decode);\n    return fcl.tx(transactionId).onceSealed();\n  }, []);\n  const fetchListings = useCallback(async () => {\n    const listings = await fcl.send([fcl.script`\n          import LocalArtistMarket from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n  \n          pub fun main(): [LocalArtistMarket.Listing] {\n            let account = getAccount(${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT})\n            let marketInterfaceRef = account\n              .getCapability(/public/LocalArtistMarket)\n              .borrow<&{LocalArtistMarket.MarketInterface}>()\n              ?? panic(\"Couldn't borrow market interface reference.\")\n          \n            return marketInterfaceRef.getListings()\n          }\n        `]).then(fcl.decode);\n    return listings;\n  }, []);\n  const postListing = useCallback(async (picture, price) => {\n    const transactionId = await fcl.send([fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n          import LocalArtistMarket from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n\n          transaction(pixels: String, price: UFix64) {\n            \n            let picture: @LocalArtist.Picture?\n            let seller: Address\n            let marketRef: &{LocalArtistMarket.MarketInterface}\n\n            prepare(account: AuthAccount) {\n              // Change to your contract account address.\n              self.marketRef = getAccount(${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT})\n                .getCapability(/public/LocalArtistMarket)\n                .borrow<&{LocalArtistMarket.MarketInterface}>()\n                ?? panic(\"Couldn't borrow market reference.\")\n              \n              let collection <- account.load<@LocalArtist.Collection>(from: /storage/LocalArtistPictureCollection)!\n              self.picture <- collection.withdraw(pixels: pixels)\n              account.save<@LocalArtist.Collection>(<- collection, to: /storage/LocalArtistPictureCollection)\n\n              self.seller = account.address\n            }\n            execute {\n              if self.picture == nil {\n                destroy self.picture\n              } else {\n                self.marketRef.sell(picture: <- self.picture!, seller: self.seller, price: price)\n              }\n            }\n          }\n        `, fcl.args([fcl.arg(picture.pixels, FlowTypes.String), fcl.arg(`${constants.flowFormat.format(price)}`, FlowTypes.UFix64)]), fcl.payer(fcl.authz), fcl.proposer(fcl.authz), fcl.authorizations([fcl.authz]), fcl.limit(9999)]).then(fcl.decode);\n    return fcl.tx(transactionId).onceSealed();\n  }, []);\n  const withdrawListing = useCallback(async listingIndex => {\n    const transactionId = await fcl.send([fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n          import LocalArtistMarket from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n\n          // Complete this transaction by calling LocalArtistMarket.withdraw().\n          transaction(listingIndex: Int) {\n\n            let seller: Address\n            let marketRef: &{LocalArtistMarket.MarketInterface}\n\n            prepare(account: AuthAccount) {\n              self.marketRef = getAccount(${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT})\n                .getCapability(/public/LocalArtistMarket)\n                .borrow<&{LocalArtistMarket.MarketInterface}>()\n                ?? panic(\"Couldn't borrow market reference.\")\n            }\n\n              self.seller = account.address\n          }\n\n          execute {\n            self.marketRef.withdraw(istingIndex: listingIndex, seller: self.seller)\n          }\n          }\n        `, fcl.args([fcl.arg(listingIndex, FlowTypes.Int)]), fcl.payer(fcl.authz), fcl.proposer(fcl.authz), fcl.authorizations([fcl.authz]), fcl.limit(9999)]).then(fcl.decode);\n    return fcl.tx(transactionId).onceSealed();\n  }, []);\n  const buy = useCallback(async listingIndex => {\n    const transactionId = await fcl.send([fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n          import LocalArtistMarket from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n          import FungibleToken from 0x9a0766d93b6608b7\n          import FlowToken from 0x7e60df042a9c0868\n\n          // Complete this transaction by calling LocalArtistMarket.buy().\n          transaction(listingIndex: Int) {\n            let marketRef: &{LocalArtistMarket.MarketInterface}\n            let sentVault: @FungibleToken.Vault\n            let buyer: Address\n\n            prepare(account: AuthAccount) {\n              self.marketRef = getAccount(${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT})\n                .getCapability(/public/LocalArtistMarket)\n                .borrow<&{LocalArtistMarket.MarketInterface}>()\n                ?? panic(\"Couldn't borrow market reference.\")\n\n              let price = self.marketRef.getListings()[listingIndex].price\n\n              let vaultRef = account\n                .borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n                ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n              self.sentVault <- vaultRef.withdraw(amount: price)\n\n              self.buyer = account.address\n\n              execute {\n                self.marketRef.buy(listing: listingIndex, with: <- self.sentVault, buyer: self.buyer)\n              }\n            }\n\n\n          }\n        `, fcl.args([fcl.arg(listingIndex, FlowTypes.Int)]), fcl.payer(fcl.authz), fcl.proposer(fcl.authz), fcl.authorizations([fcl.authz]), fcl.limit(9999)]).then(fcl.decode);\n    return fcl.tx(transactionId).onceSealed();\n  }, []);\n\n  const setUser = user => {\n    dispatch({\n      type: 'setUser',\n      payload: user\n    });\n  };\n\n  const logIn = () => {\n    fcl.logIn();\n  };\n\n  const logOut = () => {\n    fcl.unauthenticate();\n  };\n\n  useEffect(() => {\n    fcl.currentUser().subscribe(setUser);\n  }, []);\n  useEffect(() => {\n    if (state.user && state.user.addr) {\n      fetchBalance();\n      fetchCollection();\n    }\n  }, [state.user, fetchBalance, fetchCollection]);\n  return /*#__PURE__*/_jsxDEV(Context.Provider, {\n    value: {\n      state,\n      isReady,\n      dispatch,\n      logIn,\n      logOut,\n      fetchBalance,\n      fetchCollection,\n      createCollection,\n      destroyCollection,\n      printPicture,\n      fetchListings,\n      postListing,\n      withdrawListing,\n      buy\n    },\n    children: props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 439,\n    columnNumber: 5\n  }, this);\n}\n\n_s(Provider, \"UC2BXF3sgGy0xhmHRicmtfQ/k7k=\");\n\n_c = Provider;\nexport { Context as default, Provider };\n\nvar _c;\n\n$RefreshReg$(_c, \"Provider\");","map":{"version":3,"sources":["/home/evan/Documents/flow/fast-floward/quests/week1/day5/Artist/src/context/Flow.jsx"],"names":["React","useReducer","useEffect","useCallback","fcl","FlowTypes","Picture","Context","createContext","constants","flowFormat","Intl","NumberFormat","minimumFractionDigits","reducer","state","action","type","user","payload","balance","collection","Provider","props","dispatch","undefined","isReady","fetchBalance","addr","send","script","args","arg","Address","then","decode","createCollection","transactionId","transaction","process","env","REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT","payer","authz","proposer","authorizations","limit","tx","onceSealed","destroyCollection","fetchCollection","address","mappedCollection","map","serialized","pixels","width","height","error","printPicture","picture","Int","String","fetchListings","listings","postListing","price","format","UFix64","withdrawListing","listingIndex","buy","setUser","logIn","logOut","unauthenticate","currentUser","subscribe","children","default"],"mappings":"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","sourcesContent":["import React, {useReducer, useEffect, useCallback} from 'react';\nimport * as fcl from '@onflow/fcl';\nimport * as FlowTypes from '@onflow/types';\n\nimport Picture from '../model/Picture.js';\n\nconst Context = React.createContext({});\n\nconst constants = {\n  flowFormat: new Intl.NumberFormat('en-US', {\n    minimumFractionDigits: 4\n  })\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'setUser': {\n      return {\n        ...state,\n        user: action.payload\n      };\n    }\n    case 'setBalance': {\n      return {\n        ...state,\n        balance: action.payload\n      };\n    }\n    case 'setCollection': {\n      if (action.payload) {\n        return {\n          ...state,\n          collection: action.payload\n        };\n      } else {\n        return {\n          ...state,\n          collection: action.payload\n        };\n      }\n    }\n    default:\n      return state;\n  }\n}\n\nfunction Provider(props) {\n  const [state, dispatch] = useReducer(reducer, {\n    user: null,\n    balance: null,\n    collection: undefined\n  });\n\n  const isReady = (\n    state.balance !== null &&\n    state.collection !== undefined\n  );\n\n  const fetchBalance = useCallback(\n    async () => {\n      if (state.user.addr && state.user.addr !== '0xLocalArtist') {\n        // A sample script execution.\n        // Query for the account's FLOW token balance.\n        const balance = await fcl.send([\n          fcl.script`\n            import FungibleToken from 0x9a0766d93b6608b7\n            import FlowToken from 0x7e60df042a9c0868\n  \n            pub fun main(address: Address): UFix64 {\n              let vaultRef = getAccount(address)\n                .getCapability(/public/flowTokenBalance)\n                .borrow<&FlowToken.Vault{FungibleToken.Balance}>()\n                ?? panic(\"Could not borrow Balance reference to the Vault\");\n  \n              return vaultRef.balance;\n            }\n          `,\n          fcl.args([\n            fcl.arg(state.user.addr, FlowTypes.Address)\n          ])\n        ]).then(fcl.decode);\n\n        dispatch({type: 'setBalance', payload: balance});\n      } else {\n        return dispatch({type: 'setBalance', payload: -42});\n      }\n    },\n    [state.user]\n  );\n  const createCollection = useCallback(\n    async () => {\n      const transactionId = await fcl.send([\n        fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n          \n          transaction() {\n            prepare(account: AuthAccount) {\n              account.save<@LocalArtist.Collection>(\n                <- LocalArtist.createCollection(),\n                to: /storage/LocalArtistPictureCollection\n              )\n              account.link<&{LocalArtist.PictureReceiver}>(\n                /public/LocalArtistPictureReceiver,\n                target: /storage/LocalArtistPictureCollection\n              )\n            }\n          }\n        `,\n        fcl.payer(fcl.authz),\n        fcl.proposer(fcl.authz),\n        fcl.authorizations([fcl.authz]),\n        fcl.limit(9999)\n      ]).then(fcl.decode);\n      \n      return fcl.tx(transactionId).onceSealed();\n    },\n    []\n  );\n  const destroyCollection = useCallback(\n    async () => {\n      const transactionId = await fcl.send([\n        fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n\n          transaction() {\n            prepare(account: AuthAccount) {\n              account.unlink(/public/LocalArtistPictureReceiver)\n              let collection <- account.load<@LocalArtist.Collection>(from: /storage/LocalArtistPictureCollection)\n              destroy collection\n            }\n          }\n        `,\n        fcl.payer(fcl.authz),\n        fcl.proposer(fcl.authz),\n        fcl.authorizations([fcl.authz]),\n        fcl.limit(9999)\n      ]).then(fcl.decode);\n\n      return fcl.tx(transactionId).onceSealed();\n    },\n    []\n  );\n  const fetchCollection = useCallback(\n    async (address) => {\n      if (address || state.user.addr) {\n        try {\n          let args = null;\n          if (address) {\n            // eslint-disable-next-line\n            args = fcl.args([\n              fcl.arg(address, FlowTypes.Address)\n            ]);\n          } else {\n            // eslint-disable-next-line\n            args = fcl.args([\n              fcl.arg(state.user.addr, FlowTypes.Address)\n            ]);\n          }\n          \n          const collection = await fcl.send([\n            fcl.script`\n              import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n      \n              pub fun main(address: Address): [LocalArtist.Canvas] {\n                let account = getAccount(address)\n                let pictureReceiverRef = account\n                  .getCapability<&{LocalArtist.PictureReceiver}>(/public/LocalArtistPictureReceiver)\n                  .borrow()\n                  ?? panic(\"Couldn't borrow picture receiver reference.\")\n              \n                return pictureReceiverRef.getCanvases()\n              }\n            `,\n            args\n          ]).then(fcl.decode);\n          const mappedCollection = collection.map(\n            (serialized) => new Picture(\n              serialized.pixels,\n              serialized.width,\n              serialized.height\n            )\n          );\n\n          if (address) {\n            return mappedCollection;\n          } else {\n            dispatch({type: 'setCollection', payload: mappedCollection});\n          }\n        } catch (error) {\n          if (address) {\n            return null;\n          } else {\n            dispatch({type: 'setCollection', payload: null});\n          }\n        }\n      }\n    },\n    [state.user]\n  );\n  const printPicture = useCallback(\n    async (picture) => {\n      const transactionId = await fcl.send([\n        fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n\n          transaction(width: Int, height: Int, pixels: String) {\n            \n            let picture: @LocalArtist.Picture?\n            let collectionRef: &{LocalArtist.PictureReceiver}\n\n            prepare(account: AuthAccount) {\n              // Change to your contract account address.\n              let printerRef = getAccount(${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT})\n                .getCapability<&LocalArtist.Printer>(/public/LocalArtistPicturePrinter)\n                .borrow()\n                ?? panic(\"Couldn't borrow printer reference.\")\n                \n              self.picture <- printerRef.print(\n                width: width,\n                height: height,\n                pixels: pixels\n              )\n              self.collectionRef = account\n                .getCapability<&{LocalArtist.PictureReceiver}>(/public/LocalArtistPictureReceiver)\n                .borrow()\n                ?? panic(\"Couldn't borrow picture receiver reference.\")\n            }\n            execute {\n              if self.picture == nil {\n                destroy self.picture\n              } else {\n                self.collectionRef.deposit(picture: <- self.picture!)\n              }\n            }\n          }\n        `,\n        fcl.args([\n          fcl.arg(picture.width, FlowTypes.Int),\n          fcl.arg(picture.height, FlowTypes.Int),\n          fcl.arg(picture.pixels, FlowTypes.String)\n        ]),\n        fcl.payer(fcl.authz),\n        fcl.proposer(fcl.authz),\n        fcl.authorizations([fcl.authz]),\n        fcl.limit(9999)\n      ]).then(fcl.decode);\n      \n      return fcl.tx(transactionId).onceSealed();\n    },\n    []\n  );\n  const fetchListings = useCallback(\n    async () => {\n      const listings = await fcl.send([\n        fcl.script`\n          import LocalArtistMarket from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n  \n          pub fun main(): [LocalArtistMarket.Listing] {\n            let account = getAccount(${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT})\n            let marketInterfaceRef = account\n              .getCapability(/public/LocalArtistMarket)\n              .borrow<&{LocalArtistMarket.MarketInterface}>()\n              ?? panic(\"Couldn't borrow market interface reference.\")\n          \n            return marketInterfaceRef.getListings()\n          }\n        `\n      ]).then(fcl.decode);\n\n      return listings;\n    },\n    []\n  );\n  const postListing = useCallback(\n    async (picture, price) => {\n      const transactionId = await fcl.send([\n        fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n          import LocalArtistMarket from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n\n          transaction(pixels: String, price: UFix64) {\n            \n            let picture: @LocalArtist.Picture?\n            let seller: Address\n            let marketRef: &{LocalArtistMarket.MarketInterface}\n\n            prepare(account: AuthAccount) {\n              // Change to your contract account address.\n              self.marketRef = getAccount(${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT})\n                .getCapability(/public/LocalArtistMarket)\n                .borrow<&{LocalArtistMarket.MarketInterface}>()\n                ?? panic(\"Couldn't borrow market reference.\")\n              \n              let collection <- account.load<@LocalArtist.Collection>(from: /storage/LocalArtistPictureCollection)!\n              self.picture <- collection.withdraw(pixels: pixels)\n              account.save<@LocalArtist.Collection>(<- collection, to: /storage/LocalArtistPictureCollection)\n\n              self.seller = account.address\n            }\n            execute {\n              if self.picture == nil {\n                destroy self.picture\n              } else {\n                self.marketRef.sell(picture: <- self.picture!, seller: self.seller, price: price)\n              }\n            }\n          }\n        `,\n        fcl.args([\n          fcl.arg(picture.pixels, FlowTypes.String),\n          fcl.arg(`${constants.flowFormat.format(price)}`, FlowTypes.UFix64),\n        ]),\n        fcl.payer(fcl.authz),\n        fcl.proposer(fcl.authz),\n        fcl.authorizations([fcl.authz]),\n        fcl.limit(9999)\n      ]).then(fcl.decode);\n      \n      return fcl.tx(transactionId).onceSealed();\n    },\n    []\n  );\n  const withdrawListing = useCallback(\n    async (listingIndex) => {\n      const transactionId = await fcl.send([\n        fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n          import LocalArtistMarket from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n\n          // Complete this transaction by calling LocalArtistMarket.withdraw().\n          transaction(listingIndex: Int) {\n\n            let seller: Address\n            let marketRef: &{LocalArtistMarket.MarketInterface}\n\n            prepare(account: AuthAccount) {\n              self.marketRef = getAccount(${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT})\n                .getCapability(/public/LocalArtistMarket)\n                .borrow<&{LocalArtistMarket.MarketInterface}>()\n                ?? panic(\"Couldn't borrow market reference.\")\n            }\n\n              self.seller = account.address\n          }\n\n          execute {\n            self.marketRef.withdraw(istingIndex: listingIndex, seller: self.seller)\n          }\n          }\n        `,\n        fcl.args([\n          fcl.arg(listingIndex, FlowTypes.Int)\n        ]),\n        fcl.payer(fcl.authz),\n        fcl.proposer(fcl.authz),\n        fcl.authorizations([fcl.authz]),\n        fcl.limit(9999)\n      ]).then(fcl.decode);\n      \n      return fcl.tx(transactionId).onceSealed();\n    },\n    []\n  );\n  const buy = useCallback(\n    async (listingIndex) => {\n      const transactionId = await fcl.send([\n        fcl.transaction`\n          import LocalArtist from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n          import LocalArtistMarket from ${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT}\n          import FungibleToken from 0x9a0766d93b6608b7\n          import FlowToken from 0x7e60df042a9c0868\n\n          // Complete this transaction by calling LocalArtistMarket.buy().\n          transaction(listingIndex: Int) {\n            let marketRef: &{LocalArtistMarket.MarketInterface}\n            let sentVault: @FungibleToken.Vault\n            let buyer: Address\n\n            prepare(account: AuthAccount) {\n              self.marketRef = getAccount(${process.env.REACT_APP_ARTIST_CONTRACT_HOST_ACCOUNT})\n                .getCapability(/public/LocalArtistMarket)\n                .borrow<&{LocalArtistMarket.MarketInterface}>()\n                ?? panic(\"Couldn't borrow market reference.\")\n\n              let price = self.marketRef.getListings()[listingIndex].price\n\n              let vaultRef = account\n                .borrow<&FlowToken.Vault>(from: /storage/flowTokenVault)\n                ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n              self.sentVault <- vaultRef.withdraw(amount: price)\n\n              self.buyer = account.address\n\n              execute {\n                self.marketRef.buy(listing: listingIndex, with: <- self.sentVault, buyer: self.buyer)\n              }\n            }\n\n\n          }\n        `,\n        fcl.args([\n          fcl.arg(listingIndex, FlowTypes.Int)\n        ]),\n        fcl.payer(fcl.authz),\n        fcl.proposer(fcl.authz),\n        fcl.authorizations([fcl.authz]),\n        fcl.limit(9999)\n      ]).then(fcl.decode);\n      \n      return fcl.tx(transactionId).onceSealed();\n    },\n    []\n  );\n\n  const setUser = (user) => {\n    dispatch({type: 'setUser', payload: user});\n  };\n  const logIn = () => {\n    fcl.logIn();\n  };\n  const logOut = () => {\n    fcl.unauthenticate();\n  };\n\n  useEffect(() => {\n    fcl.currentUser().subscribe(setUser);\n  }, []);\n\n  useEffect(() => {\n    if (state.user && state.user.addr) {\n      fetchBalance();\n      fetchCollection();\n    }\n  }, [state.user, fetchBalance, fetchCollection]);\n\n  return (\n    <Context.Provider\n      value={{\n        state,\n        isReady,\n        dispatch,\n        logIn,\n        logOut,\n        fetchBalance,\n        fetchCollection,\n        createCollection,\n        destroyCollection,\n        printPicture,\n        fetchListings,\n        postListing,\n        withdrawListing,\n        buy\n      }}\n    >\n      {props.children}\n    </Context.Provider>\n  );\n}\n\nexport {\n  Context as default,\n  Provider\n};"]},"metadata":{},"sourceType":"module"}